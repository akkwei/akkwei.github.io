<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>知识就是力量</title>
    <link href="/2024/05/14/%E7%9F%A5%E8%AF%86%E5%B0%B1%E6%98%AF%E5%8A%9B%E9%87%8F/"/>
    <url>/2024/05/14/%E7%9F%A5%E8%AF%86%E5%B0%B1%E6%98%AF%E5%8A%9B%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="知识就是力量"><a href="#知识就是力量" class="headerlink" title="知识就是力量"></a>知识就是力量</h1><blockquote><p>人生苦短，我用Python。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello</tag>
      
      <tag>world</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试</title>
    <link href="/2024/05/14/%E9%9D%A2%E8%AF%95/"/>
    <url>/2024/05/14/%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="项目难点、解决方案"><a href="#项目难点、解决方案" class="headerlink" title="项目难点、解决方案"></a>项目难点、解决方案</h3><p>表格列可拖拽排序：注册每一个单元格的mousedown事件、记录点击位置，单元格和行信息等，注册文档的mousemove事件，设置悬浮层位置，mouseup事件判断列索引，交换两列数据，然后删除事件监听，清空悬浮层</p><p>封装的echarts图表视图不更新：将通用的echarts图表封装成组件，series数据通过父组件props传值，当父组件切换选项重新获取数据后echarts视图不更新。。。最终通过给子组件添加key值，每次获取到新的数据更改key值触发组件强制更新</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>提取视频关键帧上传图片：video canvas blob</p><p>sqlite增删改查的函数</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>减少网络请求 静态资源优化 三方类库CDN  第三方库按需引入</p><p>路由组件懒加载 component:()&#x3D;&gt;import(“”)</p><p>图片懒加载（进入视图加载）</p><p>减少dom操作 1.创建文档碎片 2.高频监听事件用节流防抖</p><h3 id="package-lock-json的作用"><a href="#package-lock-json的作用" class="headerlink" title="package.lock.json的作用"></a>package.lock.json的作用</h3><ul><li>记录间接依赖版本（依赖的依赖）</li><li>描述了生成的确切树，以便后续安装能够生成相同的树，而不管中间依赖项更新如何</li><li>使多人开发可以跨越时间和环境保持项目依赖的一致性</li></ul><h3 id="JWT和基于会话鉴权方式的比较"><a href="#JWT和基于会话鉴权方式的比较" class="headerlink" title="JWT和基于会话鉴权方式的比较"></a>JWT和基于会话鉴权方式的比较</h3><p>JWT（JSON WEB TOKEN）：用户登录后、服务器将header+payload+signature通过签名算法生成token返回给客户端，客户端将token存储到本地（localstorage、cookie），以后的请求将token字符添加到请求头中，服务器收到请求时解析token，使用秘钥验证签名，从而识别用户身份和权限</p><p>特点：无状态的，适用于分布式、跨域场景</p><p>基于会话鉴权：用户登录后，服务器创建一个会话，并将对应的session ID发送给客户端，客户端将session ID存到cookie中，并在后续请求中将session ID发送给服务器，服务器接收到session ID后查找对应会话信息，以验证用户身份和权限</p><p>特点：cookie有跨域限制，依赖于服务器会话存储，适用于单一域名下</p><h3 id="双token实现无感刷新"><a href="#双token实现无感刷新" class="headerlink" title="双token实现无感刷新"></a>双token实现无感刷新</h3><p>登录获取access_token和refresh_token，access_token过期时间比refresh_token短</p><p>access_token过期后在axios响应拦截器拦截，将请求数据添加到数组保持pending状态</p><p>api携带refresh_token去获取新的access_token，成功后遍历请求数组重新请求</p><p>需要添加一个开关过滤掉重复的获取access_token请求</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a>require.context</h3><p>require.context()是webpack的api，可以实现同类文件自动导入</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9DOTRhaWNPaWN5WHBLMzJ2eUVMc1pPSUZDZUY5aWNMejZpYTRNOTNMREg1aWFnUlZBQ1Y2d1k2Q1ZEMWMwZHA0dlh0Rm9iVnBndEd4aWN5Z1JyNmlhcnRjZHJKMWcvNjQw?x-oss-process=image/format,png" alt="img"></p><h3 id="vue-router两种模式"><a href="#vue-router两种模式" class="headerlink" title="vue-router两种模式"></a>vue-router两种模式</h3><p>hash模式是通过监听hashChange事件来实现的、#后面不会出现在请求url中，改变 hash 不会重新加载页面</p><p>history模式是通过pushState方法+popstate事件(H5新特性)来实现的、刷新页面后会请求完整路径、后端不做拦截会造成404</p><h3 id="vue-scoped原理及样式穿透"><a href="#vue-scoped原理及样式穿透" class="headerlink" title="vue scoped原理及样式穿透"></a>vue scoped原理及样式穿透</h3><p>scoped：给组件内每个元素添加data-v-hash的属性，并给最后一个选择器添加属性选择器（data-v-hash），使样式只能作用于当前组件</p><p>样式穿透：父组件内想更改第三方组件样式，也不想去除scoped，通过&gt;&gt;&gt;  ::v-deep &#x2F;deep&#x2F;等方式可让子组件选择器不带hash标识，而是在父组件中的上一级选择器带上hash标识，这样可以局部更改样式且不影响封装好的组件</p><h3 id="vue3-和-vue2-的区别"><a href="#vue3-和-vue2-的区别" class="headerlink" title="vue3 和 vue2 的区别"></a>vue3 和 vue2 的区别</h3><ul><li>v-if 和 v-for 优先级的问题</li><li>生命周期</li><li>响应式原理</li></ul><h3 id="vue3-相对于-vue2-的优化"><a href="#vue3-相对于-vue2-的优化" class="headerlink" title="vue3 相对于 vue2 的优化"></a>vue3 相对于 vue2 的优化</h3><ul><li>diff算法优化，给没有变化的节点添加静态标记避免无用节点比对消耗性能</li><li>defineProperty改为proxy代理，避免新增或删除页面无法响应，同时支持监听数组变化</li><li>fragment避免无用的层级嵌套</li><li>支持ts</li><li>组合式API更加合理</li></ul><h3 id="vue中的-nextTick有什么作用？"><a href="#vue中的-nextTick有什么作用？" class="headerlink" title="vue中的$nextTick有什么作用？"></a>vue中的$nextTick有什么作用？</h3><p>用来获取数据变化-更新后的dom，本质是一种<strong>优化策略</strong>、避免数据重复改变引起不必要的视图更新</p><p>vue中的响应式数据发生变化后不会立即更新视图、而是会开启一个异步任务队列、等所有数据变化完成后再更新视图</p><h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><p>computed：源数据逻辑处理后得到的新数据、具有缓存特性，多次调用只有第一次计算、后续调用缓存值、源数据变化后再重新计算</p><p>watch：监听数据变化、完成相应逻辑</p><h3 id="MVC和MVVM之间的区别"><a href="#MVC和MVVM之间的区别" class="headerlink" title="MVC和MVVM之间的区别"></a>MVC和MVVM之间的区别</h3><p>MVC将应用抽象为数据层（Model）、视图层（View）、逻辑层（controller），是单向数据流动，controller起承上启下的作用，数据变化需要手动更新视图</p><p>MVVM是抽离视图、数据和逻辑，view和model通过VM进行双向数据流通，vm并没有完全取代controller的作用，而是对controller的升级</p><h3 id="created和mounted有什么不同"><a href="#created和mounted有什么不同" class="headerlink" title="created和mounted有什么不同"></a>created和mounted有什么不同</h3><p>created在vue实例创建后立即调用，此时未渲染真实dom，一般用来获取数据和监听事件</p><p>mounted在vue实例挂载到真实dom后调用，此时已经渲染真实dom，可以进行一些需要dom的操作</p><h3 id="vue-lazyload用来延迟加载图片"><a href="#vue-lazyload用来延迟加载图片" class="headerlink" title="vue-lazyload用来延迟加载图片"></a>vue-lazyload用来延迟加载图片</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueLazyload</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-lazyload&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueLazyload</span>, &#123;<br>  <span class="hljs-attr">preLoad</span>: <span class="hljs-number">1.3</span>,<br>  <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;path/to/error.png&#x27;</span>,<br>  <span class="hljs-attr">loading</span>: <span class="hljs-string">&#x27;path/to/loading.gif&#x27;</span>,<br>  <span class="hljs-attr">attempt</span>: <span class="hljs-number">1</span><br>&#125;)<br><br>&lt;img v-lazy=<span class="hljs-string">&quot;imageSrc&quot;</span> alt=<span class="hljs-string">&quot;Lazy Loaded Image&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="vite和webpack的比较"><a href="#vite和webpack的比较" class="headerlink" title="vite和webpack的比较"></a>vite和webpack的比较</h3><p>vite启动速度更快：webpack会先将所有模块打包为一个bundle.js文件，然后再运行这个文件；vite实行按需动态编译，使用Rollup进行打包，提供更好的tree-shaking，代码压缩和性能优化</p><p>vite打包速度更快：vite通过ES module方式按需加载和编译模块</p><p>vite热更新更快：webpack的热更新是全量更新，即使修改一个小文件，也会重新编译整个应用，这在大型应用中可能会导致编译速度变慢；vite的热更新是增量更新，只更新修改的文件，所以即使在大型应用中也能保持极快的编译速度</p><p>vite生态不够完善：loader，plugin没有webpack生态丰富</p><p>总结：webpack适用于大型、功能复杂的项目；vite适用于中小型项目和快速开发</p><h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>模版转化为视图的过程</p><p><img src="https://cdn.jsdelivr.net/gh/akkwei/picbed@main/img/render.png" alt="render"></p><p>虚拟dom是对真实dom的抽象描述，本质是包含标签名、属性、子节点信息的js对象，相当于在真实dom和js中间做了一层缓存</p><p>提供了虚拟节点Vnode，通过新旧Vnode进行比对（diff算法），找出变化的部分将其应用在真实dom的更新上</p><p>具有跨平台（js）、高效合理更新视图的优点</p><h3 id="vue3-vite调试工具"><a href="#vue3-vite调试工具" class="headerlink" title="vue3+vite调试工具"></a>vue3+vite调试工具</h3><p>先安装npm库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install vite-plugin-vue-devtools -D<br></code></pre></td></tr></table></figure><p><u>vite.config.ts</u></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueDevTools</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite-plugin-vue-devtools&#x27;</span><br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title class_">VueDevTools</span>(),<br>    <span class="hljs-title function_">vue</span>(),<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>项目启动后可以通过<a href="http://host:port/__devtools__/单开页面使用调试，也可以在本地页面alt+shift+D在当前页使用">http://host:port/__devtools__/单开页面使用调试，也可以在本地页面alt+shift+D在当前页使用</a></p><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="普通函数和箭头函数的区别"><a href="#普通函数和箭头函数的区别" class="headerlink" title="普通函数和箭头函数的区别"></a>普通函数和箭头函数的区别</h3><ul><li>普通函数和箭头函数写法不同</li><li>箭头函数内部没有this，但箭头函数具有穿透性，箭头函数可以访问到上下文中的this，所以this的指向不同</li><li>箭头函数不能作为构造函数使用</li><li>箭头函数不具有prototype原型对象</li><li>箭头函数没有super方法</li></ul><h3 id="浏览器字体如何设置小于12px"><a href="#浏览器字体如何设置小于12px" class="headerlink" title="浏览器字体如何设置小于12px"></a>浏览器字体如何设置小于12px</h3><ul><li>transform:scale(0.5)</li><li>zoom:0.5</li></ul><h3 id="localStorage和cookie的区别"><a href="#localStorage和cookie的区别" class="headerlink" title="localStorage和cookie的区别"></a>localStorage和cookie的区别</h3><p>cookie本质是服务器颁发的一段用来记录用户信息的key-value字符串，是浏览器存储数据的一种机制，浏览器再次请求网站时会携带cookie，服务器根据cookie去辨认用户状态，具有不跨域的特征</p><p>localStorage的数据存储在本地，数据可能被类似chrome中的插件所获取</p><h3 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h3><p>在一个函数内返回另一个函数、内部函数引用外部函数的变量</p><p>函数外部也可以访问到函数内部的变量、但容易造成内存泄露</p><p>把函数内部的值保存起来或者传递到外部使用</p><h3 id="判断原则及对象转原始类型方式"><a href="#判断原则及对象转原始类型方式" class="headerlink" title="&#x3D;&#x3D;判断原则及对象转原始类型方式"></a>&#x3D;&#x3D;判断原则及对象转原始类型方式</h3><ol><li>类型相同，比较值</li><li>类型不同且都为原始类型，转为数字比较</li><li>一端为原始类型，一端是对象，对象转为原始类型后进入第一步</li></ol><p>ps：NaN和任何值都不等，undefined、null和自己或互相比较时相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>](hint) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;toPrimitive&#x27;</span>, hint);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>++;<br>    &#125;<br>    <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;valueOf&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>++;<br>    &#125;<br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;toString&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图片保持宽高比"><a href="#图片保持宽高比" class="headerlink" title="图片保持宽高比"></a>图片保持宽高比</h3><ul><li>存在兼容性问题</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span>&#123;<br>    aspect-ratio: <span class="hljs-number">4</span>/<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一般用这种方法，container容器内放置要放的元素</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.inner</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>     <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">75%</span>;<br>     <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.container</span>&#123;<br>     <span class="hljs-attribute">position</span>: absolute;<br>     inset: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浏览器地址栏输入URL并按下回车时"><a href="#浏览器地址栏输入URL并按下回车时" class="headerlink" title="浏览器地址栏输入URL并按下回车时"></a>浏览器地址栏输入URL并按下回车时</h3><p>首先浏览器进行url解析（协议，主机名，端口，参数），然后进行DNS解析域名以获取对应IP地址，浏览器通过IP和端口和服务器建立TCP连接，然后通过TCP连接向服务器发起请求，服务器收到请求后根据配置去处理并生成响应，浏览器收到响应的html后进行解析，请求css，js等文件，然后渲染页面</p><h3 id="ajax缓存及解决方案"><a href="#ajax缓存及解决方案" class="headerlink" title="ajax缓存及解决方案"></a>ajax缓存及解决方案</h3><p>ajax异步获取数据后会在浏览器缓存一份，如果后续请求地址不变的话可能获取不到最新的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>、在<span class="hljs-title class_">XMLHttpRequest</span>对象发送请企之前，可以设置请求头。<br>ajaxObject.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;If-motified-since&quot;</span>, <span class="hljs-number">0</span>)。<br><br><span class="hljs-number">2</span>、在<span class="hljs-title class_">XMLHttpFRequest</span>对象发送之前，可以设置请求头。<br>ajaxObject.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Cache-control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>)<br><br><span class="hljs-number">3</span>、可以在url后面加上一个随机数<br><span class="hljs-string">&quot;fresh=&quot;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()<br><br><span class="hljs-number">4</span>、可以在url后面加上时间戳<br><span class="hljs-string">&quot;nowtime&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()<br><br><span class="hljs-number">5</span>、如果使用的是jquery,可以这样设置$.<span class="hljs-title function_">ajaxSetup</span>(&#123;<span class="hljs-string">&quot;cache&quot;</span>: <span class="hljs-literal">false</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>是js中对象的一种连接方式，对象内部对另一个对象（原型）的引用，使对象之间可以通过原型继承的方式共享属性、方法；使js实现了面向对象的机制</p><h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p>js有着单线程非阻塞的特性，js的执行代码是在一个执行栈按照先入后出的原则执行的，js运行时环境维护着一个任务队列用来存放异步任务和事件，事件循环是js处理异步任务和事件的机制，负责不断的从任务队列取出事件放入执行栈执行</p><p>事件循环的任务分为宏任务和微任务，宏任务一般包括script代码，settimeout，setinterval，I&#x2F;O操作等，微任务一般包括promise.then；事件循环的执行顺序为先执行同步任务，再执行当前微任务队列中的所有微任务，后执行下一个宏任务</p><p><strong>微任务的执行时机是上一个宏任务执行结束之后，下一个宏任务执行开始之前；微任务优先级大于宏任务；每次事件循环只包括一个宏任务</strong></p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset [&lt;options&gt;] [&lt;commit&gt;]<br><span class="hljs-comment"># commit 可以是某个提交的哈希值或者分支名</span><br><br>git reset --soft<br><span class="hljs-comment"># 只移动指针，不改变暂存区和工作区</span><br><span class="hljs-comment"># 使用场景：节点差异会放入暂存区，这样可以将多个 commit 整合成一个，使提交记录更加清晰</span><br><br>git reset --mixed（默认）<br><span class="hljs-comment"># 移动指针，改变暂存区，不改变工作区</span><br><span class="hljs-comment"># 使用场景：</span><br><span class="hljs-comment"># 1.移除暂存区的所有更改</span><br><span class="hljs-comment"># 2.回退错误的 commit，避免错误的 commit 节点</span><br><br>git reset --hard<br><span class="hljs-comment"># 指针、暂存区、工作区都改变</span><br><span class="hljs-comment"># 使用场景：</span><br><span class="hljs-comment"># 1.抛弃某一节点之后的所有commit</span><br><span class="hljs-comment"># 2.改变本地目前的所有改变</span><br></code></pre></td></tr></table></figure><h3 id="暂存区覆盖工作区"><a href="#暂存区覆盖工作区" class="headerlink" title="暂存区覆盖工作区"></a>暂存区覆盖工作区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout .   <span class="hljs-comment">#和 git add . 是反义词 </span><br></code></pre></td></tr></table></figure><h3 id="克隆指定分支代码"><a href="#克隆指定分支代码" class="headerlink" title="克隆指定分支代码"></a>克隆指定分支代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b &lt;branch&gt; &lt;git&gt;<br></code></pre></td></tr></table></figure><h3 id="创建一个新的本地分支并将其设置为远程分支的跟踪分支"><a href="#创建一个新的本地分支并将其设置为远程分支的跟踪分支" class="headerlink" title="创建一个新的本地分支并将其设置为远程分支的跟踪分支"></a>创建一个新的本地分支并将其设置为远程分支的跟踪分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b &lt;branch&gt; origin/&lt;branch&gt;<br></code></pre></td></tr></table></figure><h3 id="查看远程仓库分支"><a href="#查看远程仓库分支" class="headerlink" title="查看远程仓库分支"></a>查看远程仓库分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -r<br></code></pre></td></tr></table></figure><h3 id="在远程创建与本地同名分支并跟踪"><a href="#在远程创建与本地同名分支并跟踪" class="headerlink" title="在远程创建与本地同名分支并跟踪"></a>在远程创建与本地同名分支并跟踪</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin &lt;branch&gt;<br></code></pre></td></tr></table></figure><h3 id="在本地创建与远程同名分支并跟踪远程分支（并切换到该分支）"><a href="#在本地创建与远程同名分支并跟踪远程分支（并切换到该分支）" class="headerlink" title="在本地创建与远程同名分支并跟踪远程分支（并切换到该分支）"></a>在本地创建与远程同名分支并跟踪远程分支（并切换到该分支）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout --track/-t origin/&lt;branch&gt;<br></code></pre></td></tr></table></figure><h3 id="将其他分支上的特定提交应用到当前分支"><a href="#将其他分支上的特定提交应用到当前分支" class="headerlink" title="将其他分支上的特定提交应用到当前分支"></a>将其他分支上的特定提交应用到当前分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout &lt;branch&gt;<br>git cherry-pick &lt;HashA&gt; &lt;HashB&gt;<br></code></pre></td></tr></table></figure><h3 id="树状图输出所有分支的提交记录"><a href="#树状图输出所有分支的提交记录" class="headerlink" title="树状图输出所有分支的提交记录"></a>树状图输出所有分支的提交记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --all --decorate --graph --oneline<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello</tag>
      
      <tag>world</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
