<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker快速入门，看了不会你捶我</title>
    <link href="/2024/05/28/docker/"/>
    <url>/2024/05/28/docker/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Docker概述"><a href="#一、Docker概述" class="headerlink" title="一、Docker概述"></a>一、Docker概述</h3><p>Docker 是一种开源的容器化技术，能够让开发者将应用及其依赖打包成一个轻量级、可移植的容器。Docker 的出现改变了传统的开发和部署方式，使得应用可以在任何环境下运行，从而大大提升了开发效率和运维可靠性。</p><p>Docker 的核心概念包括镜像（Image）、容器（Container）、仓库（Registry）、网络（Networking）和存储卷（Volumes）。</p><ul><li>镜像是一个只读模板，包含了运行应用程序所需的所有依赖。可以把镜像想象成一个快照，记录了应用程序在特定时间点的状态。</li><li>容器是镜像的一个运行实例。它包含了应用程序及其所有依赖，运行在一个独立的环境中。容器是轻量级的，启动和停止都非常快。</li><li>仓库用于存储和分发镜像。Docker Hub 是一个公共的仓库，用户可以从中拉取和推送镜像，类似于 github 等代码仓库。也可以搭建私有仓库来存储企业内部的镜像。</li><li>网络用于管理容器之间的通信。默认情况下，Docker 创建一个桥接网络，所有容器都连接到这个网络上。也可以创建自定义网络来实现更复杂的网络拓扑。</li><li>存储卷用于在容器之间共享数据或在容器重启后持久化数据。卷是 Docker 管理的数据存储位置，通常位于 Docker 主机的文件系统上。</li></ul><p>安装过程这里不提了，网上教程很丰富，命令行输入<code>docker --version</code>输出版本号就是安装好了</p><h3 id="二、与虚拟机比较"><a href="#二、与虚拟机比较" class="headerlink" title="二、与虚拟机比较"></a>二、与虚拟机比较</h3><p>共同点：都是用来实现资源隔离和应用程序部署的技术</p><p>虚拟机：</p><ul><li>每个虚拟机都有自己的完整操作系统，包括内核和系统库，这意味着多个 VM 会有多个操作系统实例运行在同一个物理主机上</li><li>每个虚拟机都运行一个完整的操作系统，资源开销较大，尤其是内存和存储</li><li>VM 提供了强隔离性，每个 VM 都有自己的操作系统，出问题时不会影响其他 VM</li><li>启动一个 VM 需要加载整个操作系统，这可能需要几分钟的时间</li><li>VM 使用虚拟磁盘（如 VMDK、VHD 等）来管理存储，存储管理复杂，每个 VM 有独立的网络接口，网络管理复杂</li><li>虚拟机镜像文件（如 VMDK、VHD）较大，迁移和复制成本高</li></ul><p>docker：</p><ul><li>依赖于 Docker 引擎来管理和运行容器</li><li>所有 Docker 容器共享主机的操作系统内核，只包含必要的应用程序和库，这减少了资源开销</li><li>容器通过命名空间（namespace）和控制组（cgroup）实现隔离，隔离性不如 VM</li><li>启动一个容器只需启动应用程序和所需的进程，通常在几秒钟内即可完成</li><li>Docker 提供了多种网络模式（桥接、主机、覆盖、无网络）来管理容器间的通信，网络管理相对简单</li><li>容器化应用可以在任何支持 Docker 的平台上运行，环境一致性高</li></ul><p><strong>总结：</strong></p><ul><li><strong>Docker</strong> 适合需要高资源利用率、快速启动和高可移植性的场景，尤其是微服务和 CI&#x2F;CD 流程。</li><li><strong>虚拟机</strong> 适合需要运行不同操作系统、需要强隔离性和高安全性的场景。</li></ul><h3 id="三、Docker概念"><a href="#三、Docker概念" class="headerlink" title="三、Docker概念"></a>三、Docker概念</h3><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>镜像由多层组成，每一层代表一次文件系统的变更（如安装软件包、复制文件等）</p><p>用户通过在项目目录内编写 <code>Dockerfile</code> 自定义应用程序的环境和依赖，然后通过<code>docker build</code>生成自定义镜像，以下为示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 基础镜像，一切从这里开始构建</span><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">14</span><br><span class="hljs-comment"># 镜像是谁写的：姓名+邮箱</span><br><span class="hljs-keyword">MAINTAINER</span> Name &lt;your.email@example.com&gt;<br><span class="hljs-comment"># 将本地文件添加到镜像中</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> src/ /app/src/</span><br><span class="hljs-comment"># 镜像的工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-comment"># 挂载的目录</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/app/logs&quot;</span>]</span><br><span class="hljs-comment"># 镜像构建的时候需要运行的命令</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install</span><br><span class="hljs-comment"># 暴露端口配置</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br><span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;app.js&quot;</span>]</span><br><span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>]</span><br><span class="hljs-comment"># 继承父镜像的Dockerfile,子镜像构建时触发执行</span><br><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This will run on the child image build&quot;</span></span><br><span class="hljs-comment"># 类似ADD，将文件拷贝到镜像中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-comment"># 构建的时候设置环境变量</span><br><span class="hljs-keyword">ENV</span> NODE_ENV=production<br></code></pre></td></tr></table></figure><p><code>Dockerfile</code>详解：</p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>是从镜像启动的一个独立运行的实例，包括应用程序和所有的依赖库、配置文件以及运行时环境</p><p>通过<code>docker run</code>从镜像启动容器，确保应用程序在任何环境中都能够一致地运行</p><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>仓库相当于<code>github</code>代码仓库，用来存储和管理镜像，本地项目目录内生成的镜像通过<code>docker push</code>提交到<code>docker hub</code>，然后可以在其他主机上通过<code>docker pull</code>拉取该镜像，然后重新创建容器，启动后即可快速部署该项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker push my_username/my_image:latest<br>docker pull my_username/my_image:latest<br></code></pre></td></tr></table></figure><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p><strong>用来管理容器之间的通信，通过网络可以将多个容器连接，互相通信</strong></p><h5 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h5><ol><li><p><strong>bridge（桥接）</strong></p><p><strong>默认类型</strong>、容器在同一主机上互相通信、适用于简单的单主机、多容器应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建网络</span><br>docker network create my_bridge_network<br><span class="hljs-comment"># 运行容器</span><br>docker run -d --name container1 --network my_bridge_network my_image<br>docker run -d --name container2 --network my_bridge_network my_image<br></code></pre></td></tr></table></figure></li><li><p><strong>host（主机网络）</strong></p><p>容器直接使用主机网络，适用于有一定网络要求的场景</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --network host my_image<br></code></pre></td></tr></table></figure></li><li><p><strong>overlay（覆盖）</strong></p><p>容器跨主机通信，需要相关集群配置</p></li><li><p><strong>none（无网络）</strong></p><p>容器无网络配置，适用于不需要网络的场景</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --network none my_image<br></code></pre></td></tr></table></figure></li></ol><h4 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h4><p><strong>用来管理容器的数据持久化，允许在容器之间共享数据，或者在容器重启或删除后保留数据</strong></p><h5 id="存储卷类型"><a href="#存储卷类型" class="headerlink" title="存储卷类型"></a>存储卷类型</h5><ol><li><p>volumes</p><p>docker管理，存储在docker文件系统内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建卷</span><br>docker volume create my_volume<br><span class="hljs-comment"># 挂载卷</span><br>docker run -d -v my_volume:/app/data my_image<br></code></pre></td></tr></table></figure></li><li><p>Bind Mounts（绑定挂载）</p><p>将主机上的目录或文件绑定到容器内的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行容器绑定挂载</span><br>docker run -d -v /host/path:/container/path my_image<br></code></pre></td></tr></table></figure></li><li><p>tmpfs Mounts（临时文件系统挂载）</p><p>在容器内创建临时文件系统，数据存储在内存中，不会持久化到磁盘，适用于存储敏感数据或需要高速读写的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行容器临时文件系统挂载</span><br>docker run -d --tmpfs /container/path my_image<br></code></pre></td></tr></table></figure></li></ol><h3 id="四、Docker命令"><a href="#四、Docker命令" class="headerlink" title="四、Docker命令"></a>四、Docker命令</h3><h4 id="镜像-1"><a href="#镜像-1" class="headerlink" title="镜像"></a>镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t &lt;image_name&gt;:&lt;tag&gt; .<br></code></pre></td></tr></table></figure><ul><li>**<code>-t</code>**：指定镜像的名称和标签</li><li>**<code>.</code>**：指定 Dockerfile 所在的路径，通常是当前目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure><ul><li>列出本地存储的所有 Docker 镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi &lt;image_name&gt;:&lt;tag&gt;<br></code></pre></td></tr></table></figure><ul><li>删除指定的镜像</li><li>可以使用镜像的 ID 或名称:标签格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull &lt;image_name&gt;:&lt;tag&gt;<br></code></pre></td></tr></table></figure><ul><li>从 Docker Hub 或其他 Docker 注册表拉取镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker save -o &lt;output_file&gt;.tar &lt;image_name&gt;:&lt;tag&gt;<br>docker load -i &lt;input_file&gt;.tar<br></code></pre></td></tr></table></figure><ul><li><strong>导出和导入镜像</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag &lt;image_name&gt;:&lt;tag&gt; &lt;docker_username&gt;/&lt;image_name&gt;:&lt;tag&gt;<br>docker push &lt;docker_username&gt;/&lt;image_name&gt;:&lt;tag&gt;<br></code></pre></td></tr></table></figure><ul><li>重新给镜像<strong>打标签</strong>，将本地镜像关联到 Docker Hub 上的仓库（不会生成新的镜像，只是对原有镜像新增了一个引用名，镜像ID不变）</li><li><strong>推送镜像</strong>，将本地镜像上传到 Docker Hub，使其可以被其他用户或系统拉取和使用</li></ul><h4 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p &lt;host_port&gt;:&lt;container_port&gt; --name &lt;container_name&gt; &lt;image_name&gt;:&lt;tag&gt;<br></code></pre></td></tr></table></figure><ul><li>**<code>-d</code>**：以分离模式运行容器</li><li>**<code>-p</code>**：将主机端口映射到容器端口</li><li>**<code>--name</code>**：为容器指定一个名称</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a<br></code></pre></td></tr></table></figure><ul><li>列出所有容器，包括停止的容器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop/start/restart/rm/logs  &lt;container_name&gt;||&lt;container_id&gt;<br>docker logs -f &lt;container_name&gt;||&lt;container_id&gt;<br></code></pre></td></tr></table></figure><ul><li>停止、启动、重启、删除容器、查看日志</li><li>查看容器实时日志</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it &lt;container_name&gt; /bin/bash<br></code></pre></td></tr></table></figure><ul><li>在运行中的容器中启动一个交互式的终端会话</li><li>**<code>-it</code>**：将终端设置为交互模式，并分配一个伪终端</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker commit &lt;container_name&gt; &lt;new_image_name&gt;:&lt;tag&gt;<br></code></pre></td></tr></table></figure><ul><li>将容器的当前状态保存为新的镜像</li></ul><h4 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有网络</span><br>docker network<br><span class="hljs-comment"># 创建、删除自定义网络</span><br>docker network create/rm my_network<br><span class="hljs-comment"># 连接、断开容器到网络</span><br>docker network connect/disconnect my_network my_container<br></code></pre></td></tr></table></figure><h4 id="存储卷-1"><a href="#存储卷-1" class="headerlink" title="存储卷"></a>存储卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 创建/删除卷</span><br>docker volume create/rm my_volume<br></code></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker system prune<br></code></pre></td></tr></table></figure><ul><li>清理未使用的容器、网络、镜像和挂载卷</li><li>使用 <code>-a</code> 选项可以删除所有未使用的资源，包括没有标签的镜像</li></ul><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p><img src="https://cdn.jsdelivr.net/gh/akkwei/picbed@main/img/docker.jpeg"></p><p>持续更新中~~~</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识就是力量</title>
    <link href="/2024/05/14/%E7%9F%A5%E8%AF%86%E5%B0%B1%E6%98%AF%E5%8A%9B%E9%87%8F/"/>
    <url>/2024/05/14/%E7%9F%A5%E8%AF%86%E5%B0%B1%E6%98%AF%E5%8A%9B%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="知识就是力量"><a href="#知识就是力量" class="headerlink" title="知识就是力量"></a>知识就是力量</h1><blockquote><p>人生苦短，我用Python。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello</tag>
      
      <tag>world</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试</title>
    <link href="/2024/05/14/%E9%9D%A2%E8%AF%95/"/>
    <url>/2024/05/14/%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="项目难点、解决方案"><a href="#项目难点、解决方案" class="headerlink" title="项目难点、解决方案"></a>项目难点、解决方案</h3><p>表格列可拖拽排序：注册每一个单元格的mousedown事件、记录点击位置，单元格和行信息等，注册文档的mousemove事件，设置悬浮层位置，mouseup事件判断列索引，交换两列数据，然后删除事件监听，清空悬浮层</p><p>封装的echarts图表视图不更新：将通用的echarts图表封装成组件，series数据通过父组件props传值，当父组件切换选项重新获取数据后echarts视图不更新。。。最终通过给子组件添加key值，每次获取到新的数据更改key值触发组件强制更新</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>提取视频关键帧上传图片：video canvas blob</p><p>sqlite增删改查的函数</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>减少网络请求 静态资源优化 三方类库CDN  第三方库按需引入</p><p>路由组件懒加载 component:()&#x3D;&gt;import(“”)</p><p>图片懒加载（进入视图加载）</p><p>减少dom操作 1.创建文档碎片 2.高频监听事件用节流防抖</p><h3 id="package-lock-json的作用"><a href="#package-lock-json的作用" class="headerlink" title="package.lock.json的作用"></a>package.lock.json的作用</h3><ul><li>记录间接依赖版本（依赖的依赖）</li><li>描述了生成的确切树，以便后续安装能够生成相同的树，而不管中间依赖项更新如何</li><li>使多人开发可以跨越时间和环境保持项目依赖的一致性</li></ul><h3 id="JWT和基于会话鉴权方式的比较"><a href="#JWT和基于会话鉴权方式的比较" class="headerlink" title="JWT和基于会话鉴权方式的比较"></a>JWT和基于会话鉴权方式的比较</h3><p>JWT（JSON WEB TOKEN）：用户登录后、服务器将header+payload+signature通过签名算法生成token返回给客户端，客户端将token存储到本地（localstorage、cookie），以后的请求将token字符添加到请求头中，服务器收到请求时解析token，使用秘钥验证签名，从而识别用户身份和权限</p><p>特点：无状态的，适用于分布式、跨域场景</p><p>基于会话鉴权：用户登录后，服务器创建一个会话，并将对应的session ID发送给客户端，客户端将session ID存到cookie中，并在后续请求中将session ID发送给服务器，服务器接收到session ID后查找对应会话信息，以验证用户身份和权限</p><p>特点：cookie有跨域限制，依赖于服务器会话存储，适用于单一域名下</p><h3 id="双token实现无感刷新"><a href="#双token实现无感刷新" class="headerlink" title="双token实现无感刷新"></a>双token实现无感刷新</h3><p>登录获取access_token和refresh_token，access_token过期时间比refresh_token短</p><p>access_token过期后在axios响应拦截器拦截，将请求数据添加到数组保持pending状态</p><p>api携带refresh_token去获取新的access_token，成功后遍历请求数组重新请求</p><p>需要添加一个开关过滤掉重复的获取access_token请求</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a>require.context</h3><p>require.context()是webpack的api，可以实现同类文件自动导入</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9DOTRhaWNPaWN5WHBLMzJ2eUVMc1pPSUZDZUY5aWNMejZpYTRNOTNMREg1aWFnUlZBQ1Y2d1k2Q1ZEMWMwZHA0dlh0Rm9iVnBndEd4aWN5Z1JyNmlhcnRjZHJKMWcvNjQw?x-oss-process=image/format,png" alt="img"></p><h3 id="vue-router两种模式"><a href="#vue-router两种模式" class="headerlink" title="vue-router两种模式"></a>vue-router两种模式</h3><p>hash模式是通过监听hashChange事件来实现的、#后面不会出现在请求url中，改变 hash 不会重新加载页面</p><p>history模式是通过pushState方法+popstate事件(H5新特性)来实现的、刷新页面后会请求完整路径、后端不做拦截会造成404</p><h3 id="vue-scoped原理及样式穿透"><a href="#vue-scoped原理及样式穿透" class="headerlink" title="vue scoped原理及样式穿透"></a>vue scoped原理及样式穿透</h3><p>scoped：给组件内每个元素添加data-v-hash的属性，并给最后一个选择器添加属性选择器（data-v-hash），使样式只能作用于当前组件</p><p>样式穿透：父组件内想更改第三方组件样式，也不想去除scoped，通过&gt;&gt;&gt;  ::v-deep &#x2F;deep&#x2F;等方式可让子组件选择器不带hash标识，而是在父组件中的上一级选择器带上hash标识，这样可以局部更改样式且不影响封装好的组件</p><h3 id="vue3-和-vue2-的区别"><a href="#vue3-和-vue2-的区别" class="headerlink" title="vue3 和 vue2 的区别"></a>vue3 和 vue2 的区别</h3><ul><li>v-if 和 v-for 优先级的问题</li><li>生命周期</li><li>响应式原理</li></ul><h3 id="vue3-相对于-vue2-的优化"><a href="#vue3-相对于-vue2-的优化" class="headerlink" title="vue3 相对于 vue2 的优化"></a>vue3 相对于 vue2 的优化</h3><ul><li>diff算法优化，给没有变化的节点添加静态标记避免无用节点比对消耗性能</li><li>defineProperty改为proxy代理，避免新增或删除页面无法响应，同时支持监听数组变化</li><li>fragment避免无用的层级嵌套</li><li>支持ts</li><li>组合式API更加合理</li></ul><h3 id="vue中的-nextTick有什么作用？"><a href="#vue中的-nextTick有什么作用？" class="headerlink" title="vue中的$nextTick有什么作用？"></a>vue中的$nextTick有什么作用？</h3><p>用来获取数据变化-更新后的dom，本质是一种<strong>优化策略</strong>、避免数据重复改变引起不必要的视图更新</p><p>vue中的响应式数据发生变化后不会立即更新视图、而是会开启一个异步任务队列、等所有数据变化完成后再更新视图</p><h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><p>computed：源数据逻辑处理后得到的新数据、具有缓存特性，多次调用只有第一次计算、后续调用缓存值、源数据变化后再重新计算</p><p>watch：监听数据变化、完成相应逻辑</p><h3 id="MVC和MVVM之间的区别"><a href="#MVC和MVVM之间的区别" class="headerlink" title="MVC和MVVM之间的区别"></a>MVC和MVVM之间的区别</h3><p>MVC将应用抽象为数据层（Model）、视图层（View）、逻辑层（controller），是单向数据流动，controller起承上启下的作用，数据变化需要手动更新视图</p><p>MVVM是抽离视图、数据和逻辑，view和model通过VM进行双向数据流通，vm并没有完全取代controller的作用，而是对controller的升级</p><h3 id="created和mounted有什么不同"><a href="#created和mounted有什么不同" class="headerlink" title="created和mounted有什么不同"></a>created和mounted有什么不同</h3><p>created在vue实例创建后立即调用，此时未渲染真实dom，一般用来获取数据和监听事件</p><p>mounted在vue实例挂载到真实dom后调用，此时已经渲染真实dom，可以进行一些需要dom的操作</p><h3 id="vue-lazyload用来延迟加载图片"><a href="#vue-lazyload用来延迟加载图片" class="headerlink" title="vue-lazyload用来延迟加载图片"></a>vue-lazyload用来延迟加载图片</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueLazyload</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-lazyload&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueLazyload</span>, &#123;<br>  <span class="hljs-attr">preLoad</span>: <span class="hljs-number">1.3</span>,<br>  <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;path/to/error.png&#x27;</span>,<br>  <span class="hljs-attr">loading</span>: <span class="hljs-string">&#x27;path/to/loading.gif&#x27;</span>,<br>  <span class="hljs-attr">attempt</span>: <span class="hljs-number">1</span><br>&#125;)<br><br>&lt;img v-lazy=<span class="hljs-string">&quot;imageSrc&quot;</span> alt=<span class="hljs-string">&quot;Lazy Loaded Image&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="vite和webpack的比较"><a href="#vite和webpack的比较" class="headerlink" title="vite和webpack的比较"></a>vite和webpack的比较</h3><p>vite启动速度更快：webpack会先将所有模块打包为一个bundle.js文件，然后再运行这个文件；vite实行按需动态编译，使用Rollup进行打包，提供更好的tree-shaking，代码压缩和性能优化</p><p>vite打包速度更快：vite通过ES module方式按需加载和编译模块</p><p>vite热更新更快：webpack的热更新是全量更新，即使修改一个小文件，也会重新编译整个应用，这在大型应用中可能会导致编译速度变慢；vite的热更新是增量更新，只更新修改的文件，所以即使在大型应用中也能保持极快的编译速度</p><p>vite生态不够完善：loader，plugin没有webpack生态丰富</p><p>总结：webpack适用于大型、功能复杂的项目；vite适用于中小型项目和快速开发</p><h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>模版转化为视图的过程</p><p><img src="https://cdn.jsdelivr.net/gh/akkwei/picbed@main/img/render.png" alt="render"></p><p>虚拟dom是对真实dom的抽象描述，本质是包含标签名、属性、子节点信息的js对象，相当于在真实dom和js中间做了一层缓存</p><p>提供了虚拟节点Vnode，通过新旧Vnode进行比对（diff算法），找出变化的部分将其应用在真实dom的更新上</p><p>具有跨平台（js）、高效合理更新视图的优点</p><h3 id="vue3-vite调试工具"><a href="#vue3-vite调试工具" class="headerlink" title="vue3+vite调试工具"></a>vue3+vite调试工具</h3><p>先安装npm库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install vite-plugin-vue-devtools -D<br></code></pre></td></tr></table></figure><p><u>vite.config.ts</u></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueDevTools</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite-plugin-vue-devtools&#x27;</span><br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title class_">VueDevTools</span>(),<br>    <span class="hljs-title function_">vue</span>(),<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>项目启动后可以通过<a href="http://host:port/__devtools__/单开页面使用调试，也可以在本地页面alt+shift+D在当前页使用">http://host:port/__devtools__/单开页面使用调试，也可以在本地页面alt+shift+D在当前页使用</a></p><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="普通函数和箭头函数的区别"><a href="#普通函数和箭头函数的区别" class="headerlink" title="普通函数和箭头函数的区别"></a>普通函数和箭头函数的区别</h3><ul><li>普通函数和箭头函数写法不同</li><li>箭头函数内部没有this，但箭头函数具有穿透性，箭头函数可以访问到上下文中的this，所以this的指向不同</li><li>箭头函数不能作为构造函数使用</li><li>箭头函数不具有prototype原型对象</li><li>箭头函数没有super方法</li></ul><h3 id="浏览器字体如何设置小于12px"><a href="#浏览器字体如何设置小于12px" class="headerlink" title="浏览器字体如何设置小于12px"></a>浏览器字体如何设置小于12px</h3><ul><li>transform:scale(0.5)</li><li>zoom:0.5</li></ul><h3 id="localStorage和cookie的区别"><a href="#localStorage和cookie的区别" class="headerlink" title="localStorage和cookie的区别"></a>localStorage和cookie的区别</h3><p>cookie本质是服务器颁发的一段用来记录用户信息的key-value字符串，是浏览器存储数据的一种机制，浏览器再次请求网站时会携带cookie，服务器根据cookie去辨认用户状态，具有不跨域的特征</p><p>localStorage的数据存储在本地，数据可能被类似chrome中的插件所获取</p><h3 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h3><p>在一个函数内返回另一个函数、内部函数引用外部函数的变量</p><p>函数外部也可以访问到函数内部的变量、但容易造成内存泄露</p><p>把函数内部的值保存起来或者传递到外部使用</p><h3 id="判断原则及对象转原始类型方式"><a href="#判断原则及对象转原始类型方式" class="headerlink" title="&#x3D;&#x3D;判断原则及对象转原始类型方式"></a>&#x3D;&#x3D;判断原则及对象转原始类型方式</h3><ol><li>类型相同，比较值</li><li>类型不同且都为原始类型，转为数字比较</li><li>一端为原始类型，一端是对象，对象转为原始类型后进入第一步</li></ol><p>ps：NaN和任何值都不等，undefined、null和自己或互相比较时相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>](hint) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;toPrimitive&#x27;</span>, hint);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>++;<br>    &#125;<br>    <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;valueOf&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>++;<br>    &#125;<br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;toString&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图片保持宽高比"><a href="#图片保持宽高比" class="headerlink" title="图片保持宽高比"></a>图片保持宽高比</h3><ul><li>存在兼容性问题</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span>&#123;<br>    aspect-ratio: <span class="hljs-number">4</span>/<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一般用这种方法，container容器内放置要放的元素</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.inner</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>     <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">75%</span>;<br>     <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.container</span>&#123;<br>     <span class="hljs-attribute">position</span>: absolute;<br>     inset: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浏览器地址栏输入URL并按下回车时"><a href="#浏览器地址栏输入URL并按下回车时" class="headerlink" title="浏览器地址栏输入URL并按下回车时"></a>浏览器地址栏输入URL并按下回车时</h3><p>首先浏览器进行url解析（协议，主机名，端口，参数），然后进行DNS解析域名以获取对应IP地址，浏览器通过IP和端口和服务器建立TCP连接，然后通过TCP连接向服务器发起请求，服务器收到请求后根据配置去处理并生成响应，浏览器收到响应的html后进行解析，请求css，js等文件，然后渲染页面</p><h3 id="ajax缓存及解决方案"><a href="#ajax缓存及解决方案" class="headerlink" title="ajax缓存及解决方案"></a>ajax缓存及解决方案</h3><p>ajax异步获取数据后会在浏览器缓存一份，如果后续请求地址不变的话可能获取不到最新的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>、在<span class="hljs-title class_">XMLHttpRequest</span>对象发送请企之前，可以设置请求头。<br>ajaxObject.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;If-motified-since&quot;</span>, <span class="hljs-number">0</span>)。<br><br><span class="hljs-number">2</span>、在<span class="hljs-title class_">XMLHttpFRequest</span>对象发送之前，可以设置请求头。<br>ajaxObject.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Cache-control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>)<br><br><span class="hljs-number">3</span>、可以在url后面加上一个随机数<br><span class="hljs-string">&quot;fresh=&quot;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()<br><br><span class="hljs-number">4</span>、可以在url后面加上时间戳<br><span class="hljs-string">&quot;nowtime&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()<br><br><span class="hljs-number">5</span>、如果使用的是jquery,可以这样设置$.<span class="hljs-title function_">ajaxSetup</span>(&#123;<span class="hljs-string">&quot;cache&quot;</span>: <span class="hljs-literal">false</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>是js中对象的一种连接方式，对象内部对另一个对象（原型）的引用，使对象之间可以通过原型继承的方式共享属性、方法；使js实现了面向对象的机制</p><h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p>js有着单线程非阻塞的特性，js的执行代码是在一个执行栈按照先入后出的原则执行的，js运行时环境维护着一个任务队列用来存放异步任务和事件，事件循环是js处理异步任务和事件的机制，负责不断的从任务队列取出事件放入执行栈执行</p><p>事件循环的任务分为宏任务和微任务，宏任务一般包括script代码，settimeout，setinterval，I&#x2F;O操作等，微任务一般包括promise.then；事件循环的执行顺序为先执行同步任务，再执行当前微任务队列中的所有微任务，后执行下一个宏任务</p><p><strong>微任务的执行时机是上一个宏任务执行结束之后，下一个宏任务执行开始之前；微任务优先级大于宏任务；每次事件循环只包括一个宏任务</strong></p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset [&lt;options&gt;] [&lt;commit&gt;]<br><span class="hljs-comment"># commit 可以是某个提交的哈希值或者分支名</span><br><br>git reset --soft<br><span class="hljs-comment"># 只移动指针，不改变暂存区和工作区</span><br><span class="hljs-comment"># 使用场景：节点差异会放入暂存区，这样可以将多个 commit 整合成一个，使提交记录更加清晰</span><br><br>git reset --mixed（默认）<br><span class="hljs-comment"># 移动指针，改变暂存区，不改变工作区</span><br><span class="hljs-comment"># 使用场景：</span><br><span class="hljs-comment"># 1.移除暂存区的所有更改</span><br><span class="hljs-comment"># 2.回退错误的 commit，避免错误的 commit 节点</span><br><br>git reset --hard<br><span class="hljs-comment"># 指针、暂存区、工作区都改变</span><br><span class="hljs-comment"># 使用场景：</span><br><span class="hljs-comment"># 1.抛弃某一节点之后的所有commit</span><br><span class="hljs-comment"># 2.改变本地目前的所有改变</span><br></code></pre></td></tr></table></figure><h3 id="暂存区覆盖工作区"><a href="#暂存区覆盖工作区" class="headerlink" title="暂存区覆盖工作区"></a>暂存区覆盖工作区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout .   <span class="hljs-comment">#和 git add . 是反义词 </span><br></code></pre></td></tr></table></figure><h3 id="克隆指定分支代码"><a href="#克隆指定分支代码" class="headerlink" title="克隆指定分支代码"></a>克隆指定分支代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b &lt;branch&gt; &lt;git&gt;<br></code></pre></td></tr></table></figure><h3 id="创建一个新的本地分支并将其设置为远程分支的跟踪分支"><a href="#创建一个新的本地分支并将其设置为远程分支的跟踪分支" class="headerlink" title="创建一个新的本地分支并将其设置为远程分支的跟踪分支"></a>创建一个新的本地分支并将其设置为远程分支的跟踪分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b &lt;branch&gt; origin/&lt;branch&gt;<br></code></pre></td></tr></table></figure><h3 id="查看远程仓库分支"><a href="#查看远程仓库分支" class="headerlink" title="查看远程仓库分支"></a>查看远程仓库分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -r<br></code></pre></td></tr></table></figure><h3 id="在远程创建与本地同名分支并跟踪"><a href="#在远程创建与本地同名分支并跟踪" class="headerlink" title="在远程创建与本地同名分支并跟踪"></a>在远程创建与本地同名分支并跟踪</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin &lt;branch&gt;<br></code></pre></td></tr></table></figure><h3 id="在本地创建与远程同名分支并跟踪远程分支（并切换到该分支）"><a href="#在本地创建与远程同名分支并跟踪远程分支（并切换到该分支）" class="headerlink" title="在本地创建与远程同名分支并跟踪远程分支（并切换到该分支）"></a>在本地创建与远程同名分支并跟踪远程分支（并切换到该分支）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout --track/-t origin/&lt;branch&gt;<br></code></pre></td></tr></table></figure><h3 id="将其他分支上的特定提交应用到当前分支"><a href="#将其他分支上的特定提交应用到当前分支" class="headerlink" title="将其他分支上的特定提交应用到当前分支"></a>将其他分支上的特定提交应用到当前分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout &lt;branch&gt;<br>git cherry-pick &lt;HashA&gt; &lt;HashB&gt;<br></code></pre></td></tr></table></figure><h3 id="树状图输出所有分支的提交记录"><a href="#树状图输出所有分支的提交记录" class="headerlink" title="树状图输出所有分支的提交记录"></a>树状图输出所有分支的提交记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --all --decorate --graph --oneline<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello</tag>
      
      <tag>world</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
